{"ast":null,"code":"import * as XLSX from 'xlsx';\n// 将列索引转换为Excel列名 (0->A, 1->B, etc.)\nconst getColumnName = index => {\n  let result = '';\n  while (index >= 0) {\n    result = String.fromCharCode(65 + index % 26) + result;\n    index = Math.floor(index / 26) - 1;\n  }\n  return result;\n};\n\n// 解析灰阶数据：从B1开始，每隔22个单元格获取下一个值\nexport const parseGrayScaleData = worksheet => {\n  const values = [];\n  const positions = [];\n  let currentRow = 1; // 从第1行开始\n  const column = 'B'; // B列\n\n  while (true) {\n    const cellAddress = `${column}${currentRow}`;\n    const cell = worksheet[cellAddress];\n\n    // 如果单元格为空或不存在，停止解析\n    if (!cell || cell.v === undefined || cell.v === null || cell.v === '') {\n      break;\n    }\n    const value = typeof cell.v === 'number' ? cell.v : parseFloat(cell.v.toString());\n    if (!isNaN(value)) {\n      values.push(value);\n      positions.push(cellAddress);\n    }\n    currentRow += 22; // 每隔22个单元格\n  }\n  return {\n    values,\n    positions\n  };\n};\n\n// 解析亮度数据块：按照规律生成所有数据块，每隔22行一个32x20的矩阵\nexport const parseBrightnessBlocks = worksheet => {\n  const blocks = [];\n  let blockIndex = 1;\n  let currentStartRow = 2; // 从第2行开始\n\n  // 持续解析直到找不到有效数据\n  while (true) {\n    const currentEndRow = currentStartRow + 19; // 每个块20行数据\n    const data = [];\n    let hasValidData = false;\n\n    // 解析32列 (A到AF) x 20行的数据\n    for (let row = currentStartRow; row <= currentEndRow; row++) {\n      const rowData = [];\n\n      // 从A列(0)到AF列(31)，共32列\n      for (let col = 0; col < 32; col++) {\n        const columnName = getColumnName(col);\n        const cellAddress = `${columnName}${row}`;\n        const cell = worksheet[cellAddress];\n        let value = 0;\n        if (cell && cell.v !== undefined && cell.v !== null && cell.v !== '') {\n          const parsedValue = typeof cell.v === 'number' ? cell.v : parseFloat(cell.v.toString());\n          if (!isNaN(parsedValue)) {\n            value = parsedValue;\n            hasValidData = true;\n          }\n        }\n        rowData.push(value);\n      }\n      data.push(rowData);\n    }\n\n    // 如果这个块没有任何有效数据，停止解析\n    if (!hasValidData) {\n      break;\n    }\n\n    // 计算中心像素值 (32x20矩阵的中心位置为第16列，第10行)\n    const centerRow = 9; // 第10行 (0-based index)\n    const centerCol = 15; // 第16列 (0-based index)\n    const centerPixelValue = data[centerRow] && data[centerRow][centerCol] ? data[centerRow][centerCol] : 0;\n\n    // 计算归一化数据（以中心像素为基准）\n    const normalizedData = data.map(row => row.map(value => centerPixelValue !== 0 ? value / centerPixelValue : 0));\n    blocks.push({\n      data,\n      normalizedData,\n      startRow: currentStartRow,\n      endRow: currentEndRow,\n      label: `数据块 ${blockIndex} (A${currentStartRow}-AF${currentEndRow})`,\n      centerPixelValue\n    });\n    blockIndex++;\n    currentStartRow += 22; // 每隔22行开始下一个数据块\n  }\n  return blocks;\n};\n\n// 主解析函数\nexport const parseExcelData = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        var _e$target;\n        const data = new Uint8Array((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.result);\n        const workbook = XLSX.read(data, {\n          type: 'array'\n        });\n\n        // 获取第一个工作表\n        const sheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[sheetName];\n\n        // 解析数据\n        const grayScale = parseGrayScaleData(worksheet);\n        const brightnessBlocks = parseBrightnessBlocks(worksheet);\n        resolve({\n          grayScale,\n          brightnessBlocks\n        });\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => {\n      reject(new Error('文件读取失败'));\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};","map":{"version":3,"names":["XLSX","getColumnName","index","result","String","fromCharCode","Math","floor","parseGrayScaleData","worksheet","values","positions","currentRow","column","cellAddress","cell","v","undefined","value","parseFloat","toString","isNaN","push","parseBrightnessBlocks","blocks","blockIndex","currentStartRow","currentEndRow","data","hasValidData","row","rowData","col","columnName","parsedValue","centerRow","centerCol","centerPixelValue","normalizedData","map","startRow","endRow","label","parseExcelData","file","Promise","resolve","reject","reader","FileReader","onload","e","_e$target","Uint8Array","target","workbook","read","type","sheetName","SheetNames","Sheets","grayScale","brightnessBlocks","error","onerror","Error","readAsArrayBuffer"],"sources":["D:/source/fitdata/fitdata-visualizer/src/utils/dataParser.ts"],"sourcesContent":["import * as XLSX from 'xlsx';\n\nexport interface GrayScaleData {\n  values: number[];\n  positions: string[];\n}\n\nexport interface BrightnessBlock {\n  data: number[][];\n  normalizedData?: number[][];\n  startRow: number;\n  endRow: number;\n  label: string;\n  centerPixelValue: number;\n}\n\nexport interface ParsedData {\n  grayScale: GrayScaleData;\n  brightnessBlocks: BrightnessBlock[];\n}\n\n// 将列索引转换为Excel列名 (0->A, 1->B, etc.)\nconst getColumnName = (index: number): string => {\n  let result = '';\n  while (index >= 0) {\n    result = String.fromCharCode(65 + (index % 26)) + result;\n    index = Math.floor(index / 26) - 1;\n  }\n  return result;\n};\n\n// 解析灰阶数据：从B1开始，每隔22个单元格获取下一个值\nexport const parseGrayScaleData = (worksheet: XLSX.WorkSheet): GrayScaleData => {\n  const values: number[] = [];\n  const positions: string[] = [];\n  \n  let currentRow = 1; // 从第1行开始\n  const column = 'B'; // B列\n  \n  while (true) {\n    const cellAddress = `${column}${currentRow}`;\n    const cell = worksheet[cellAddress];\n    \n    // 如果单元格为空或不存在，停止解析\n    if (!cell || cell.v === undefined || cell.v === null || cell.v === '') {\n      break;\n    }\n    \n    const value = typeof cell.v === 'number' ? cell.v : parseFloat(cell.v.toString());\n    if (!isNaN(value)) {\n      values.push(value);\n      positions.push(cellAddress);\n    }\n    \n    currentRow += 22; // 每隔22个单元格\n  }\n  \n  return { values, positions };\n};\n\n// 解析亮度数据块：按照规律生成所有数据块，每隔22行一个32x20的矩阵\nexport const parseBrightnessBlocks = (worksheet: XLSX.WorkSheet): BrightnessBlock[] => {\n  const blocks: BrightnessBlock[] = [];\n  \n  let blockIndex = 1;\n  let currentStartRow = 2; // 从第2行开始\n  \n  // 持续解析直到找不到有效数据\n  while (true) {\n    const currentEndRow = currentStartRow + 19; // 每个块20行数据\n    const data: number[][] = [];\n    let hasValidData = false;\n    \n    // 解析32列 (A到AF) x 20行的数据\n    for (let row = currentStartRow; row <= currentEndRow; row++) {\n      const rowData: number[] = [];\n      \n      // 从A列(0)到AF列(31)，共32列\n      for (let col = 0; col < 32; col++) {\n        const columnName = getColumnName(col);\n        const cellAddress = `${columnName}${row}`;\n        const cell = worksheet[cellAddress];\n        \n        let value = 0;\n        if (cell && cell.v !== undefined && cell.v !== null && cell.v !== '') {\n          const parsedValue = typeof cell.v === 'number' ? cell.v : parseFloat(cell.v.toString());\n          if (!isNaN(parsedValue)) {\n            value = parsedValue;\n            hasValidData = true;\n          }\n        }\n        \n        rowData.push(value);\n      }\n      \n      data.push(rowData);\n    }\n    \n    // 如果这个块没有任何有效数据，停止解析\n    if (!hasValidData) {\n      break;\n    }\n    \n    // 计算中心像素值 (32x20矩阵的中心位置为第16列，第10行)\n    const centerRow = 9; // 第10行 (0-based index)\n    const centerCol = 15; // 第16列 (0-based index)\n    const centerPixelValue = data[centerRow] && data[centerRow][centerCol] ? data[centerRow][centerCol] : 0;\n    \n    // 计算归一化数据（以中心像素为基准）\n    const normalizedData: number[][] = data.map(row => \n      row.map(value => centerPixelValue !== 0 ? value / centerPixelValue : 0)\n    );\n    \n    blocks.push({\n      data,\n      normalizedData,\n      startRow: currentStartRow,\n      endRow: currentEndRow,\n      label: `数据块 ${blockIndex} (A${currentStartRow}-AF${currentEndRow})`,\n      centerPixelValue\n    });\n    \n    blockIndex++;\n    currentStartRow += 22; // 每隔22行开始下一个数据块\n  }\n  \n  return blocks;\n};\n\n// 主解析函数\nexport const parseExcelData = (file: File): Promise<ParsedData> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    \n    reader.onload = (e) => {\n      try {\n        const data = new Uint8Array(e.target?.result as ArrayBuffer);\n        const workbook = XLSX.read(data, { type: 'array' });\n        \n        // 获取第一个工作表\n        const sheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[sheetName];\n        \n        // 解析数据\n        const grayScale = parseGrayScaleData(worksheet);\n        const brightnessBlocks = parseBrightnessBlocks(worksheet);\n        \n        resolve({\n          grayScale,\n          brightnessBlocks\n        });\n      } catch (error) {\n        reject(error);\n      }\n    };\n    \n    reader.onerror = () => {\n      reject(new Error('文件读取失败'));\n    };\n    \n    reader.readAsArrayBuffer(file);\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}